# azure-iot-location-monitoring\.github\workflows\GithubActionsFullDeploy.yml

name: GitHub Actions Full IoT Solution Deployment

on:
  workflow_dispatch:  # Manual trigger from GitHub UI

# Change to this after debugging...
# on:
#   push:
#     branches: [ main ]

jobs:
  deploy-solution:
    runs-on: ubuntu-latest

    env:
      ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

    steps:
      # --- 1. Terraform Infrastructure Deployment ---
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.8.x

      - name: Terraform Init
        id: init
        run: terraform init
        working-directory: ./terraform


      # control + / = comment
      # control + / = uncomment
      # - name: Force Unlock Terraform State (on failure/cancel with specific ID)
      #   if: ${{ failure() || cancelled() }} # This condition checks the overall job status
      #   run: |
      #     echo "Attempting to find and force unlock the Terraform state lock ID..."

      #     TF_BACKEND_ACCOUNT_NAME="iotlocationmon20250621"
      #     TF_BACKEND_CONTAINER_NAME="tfstate"
      #     TF_STATE_BLOB_KEY="iot-solution.tfstate"

      #     LOCK_ID=$(az storage blob metadata show \
      #       --account-name "$TF_BACKEND_ACCOUNT_NAME" \
      #       --container-name "$TF_BACKEND_CONTAINER_NAME" \
      #       --name "$TF_STATE_BLOB_KEY" \
      #       --query "metadata.terraformlockid" \
      #       --output tsv 2>/dev/null)

      #     if [ -n "$LOCK_ID" ]; then
      #       echo "💡 Found active lock ID: $LOCK_ID from Azure Storage metadata. Attempting force unlock..."
      #       terraform force-unlock -force "$LOCK_ID" || {
      #         echo "⚠️ Warning: terraform force-unlock failed for ID $LOCK_ID. It might already be cleared or another issue exists."
      #       }
      #       echo "✅ Terraform force-unlock command completed for ID: $LOCK_ID."
      #     else
      #       echo "✅ No active lock ID found in Azure Storage metadata for '$TF_STATE_BLOB_KEY'. No unlock needed."
      #     fi
      #   working-directory: ./terraform
      #   # `env` variables for ARM_CLIENT_ID etc. are inherited from the job level, which is sufficient here.

      # - name: Force Unlock State (preemptive before apply)
      #   if: always()
      #   shell: bash
      #   run: |
      #     echo "🔐 Checking Azure Storage metadata for stale Terraform lock..."

      #     STORAGE_ACCOUNT="iotlocationmon20250621"
      #     CONTAINER_NAME="tfstate"
      #     STATE_BLOB="iot-solution.tfstate"

      #     LOCK_ID=$(az storage blob metadata show \
      #       --account-name "$STORAGE_ACCOUNT" \
      #       --container-name "$CONTAINER_NAME" \
      #       --name "$STATE_BLOB" \
      #       --query "metadata.terraformlockid" \
      #       --output tsv 2>/dev/null || echo "")

      #     if [ -n "$LOCK_ID" ]; then
      #       echo "💡 Found existing lock ID: $LOCK_ID — forcing unlock..."
      #       terraform force-unlock -force "$LOCK_ID" || echo "⚠️ Unlock failed or already cleared."
      #     else
      #       echo "✅ No stale lock found. Proceeding to apply."
      #     fi
      #   working-directory: ./terraform
      #   env:
      #     ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
      #     ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
      #     ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      #     ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        
      # - name: Force break Azure Blob lease if locked
      #   if: always()
      #   shell: bash
      #   run: |
      #     echo "🔐 Checking blob lease status..."

      #     STORAGE_ACCOUNT="iotlocationmon20250621"
      #     CONTAINER_NAME="tfstate"
      #     STATE_BLOB="iot-solution.tfstate"

      #     LEASE_STATE=$(az storage blob show \
      #       --account-name "$STORAGE_ACCOUNT" \
      #       --container-name "$CONTAINER_NAME" \
      #       --name "$STATE_BLOB" \
      #       --query "properties.lease.state" \
      #       --output tsv)

      #     if [ "$LEASE_STATE" == "leased" ]; then
      #       echo "💡 Blob is leased — breaking lease to unlock state..."
      #       az storage blob lease break \
      #         --account-name "$STORAGE_ACCOUNT" \
      #         --container-name "$CONTAINER_NAME" \
      #         --blob "$STATE_BLOB" \
      #         --output none || echo "⚠️ Lease break failed or already cleared."
      #     else
      #       echo "✅ Blob is not currently leased. No unlock needed."
      #     fi
      #   working-directory: ./terraform
      #   env:
      #     ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
      #     ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
      #     ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      #     ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}  

      - name: Conditionally import resource group if it exists
        run: |
          RG_NAME="iot-location-rg"
          SUB_ID="${{ secrets.AZURE_SUBSCRIPTION_ID }}"

          echo "🔍 Checking if Resource Group '$RG_NAME' exists in Azure..."
          if az group show --name "$RG_NAME" --output none 2>/dev/null; then
            echo "✅ Resource group '$RG_NAME' exists."
            if ! terraform state show azurerm_resource_group.iot_resource_group &>/dev/null; then
              echo "🛠️ Importing '$RG_NAME' into Terraform state..."
              terraform import azurerm_resource_group.iot_resource_group "/subscriptions/$SUB_ID/resourceGroups/$RG_NAME"
            else
              echo "🪪 Resource group already in Terraform state. No import needed."
            fi
          else
            echo "❌ Resource group '$RG_NAME' does not exist in Azure. Skipping import."
          fi
        working-directory: ./terraform
        shell: bash
        env:
          TF_VAR_github_client_id: ${{ secrets.AZURE_CLIENT_ID }}
          TF_VAR_github_client_secret: ${{ secrets.AZURE_CLIENT_SECRET }}
          TF_VAR_github_tenant_id: ${{ secrets.AZURE_TENANT_ID }}
          TF_VAR_github_subscription_id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Terraform Apply
        id: apply
        run: terraform apply -auto-approve
        working-directory: ./terraform
        env:
          TF_VAR_github_client_id: ${{ secrets.AZURE_CLIENT_ID }}
          TF_VAR_github_client_secret: ${{ secrets.AZURE_CLIENT_SECRET }}
          TF_VAR_github_tenant_id: ${{ secrets.AZURE_TENANT_ID }}
          TF_VAR_github_subscription_id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

      # --- 2. Extract Outputs from Terraform ---
      - name: Get Terraform Outputs (all except for IOTHUB_DEVICE_CONNECTION_STRING)
        id: terraform_outputs
        run: |    

          
          TERRAFORM_OUTPUTS=$(terraform output -json)
          echo "IOT_SIMULATOR_DEVICE_NAME=$(echo $TERRAFORM_OUTPUTS | jq -r '.iot_simulator_device_name.value')" >> $GITHUB_OUTPUT
          
          AKS_KUBECFG_RAW=$(echo $TERRAFORM_OUTPUTS | jq -r '.aks_kube_config.value')
          echo "AKS_KUBECFG=$(echo "$AKS_KUBECFG_RAW" | tr -d '\n')" >> $GITHUB_OUTPUT

          # echo "AKS_KUBECFG=$(echo $TERRAFORM_OUTPUTS | jq -r '.aks_kube_config.value' | tr -d '\r')" >> $GITHUB_OUTPUT
          echo "Outputting AKS_KUBECFG_RAW"
          echo $AKS_KUBECFG_RAW
          # echo "Outputting AKS_KUBECFG"
          # echo $AKS_KUBECFG

          echo "Outputting steps.terraform_outputs.outputs.aks_kube_config"
          echo "${{ steps.terraform_outputs.outputs.aks_kube_config }}"
          echo "Outputting steps.terraform_outputs.outputs.AKS_KUBECFG"
          echo "${{ steps.terraform_outputs.outputs.AKS_KUBECFG }}"

          echo "ACR_LOGIN_SERVER=$(echo $TERRAFORM_OUTPUTS | jq -r '.acr_login_server.value')" >> $GITHUB_OUTPUT
          echo "IOT_HUB_NAME=$(echo "$TERRAFORM_OUTPUTS" | jq -r '.iot_hub_name.value')" >> "$GITHUB_OUTPUT"
          echo "RESOURCE_GROUP_NAME=$(echo "$TERRAFORM_OUTPUTS" | jq -r '.resource_group_name.value')" >> "$GITHUB_OUTPUT"


        working-directory: ./terraform


      - name: Get IoT device connection string via Azure CLI
        id: get_conn_str
        run: |
          conn_str=$(az iot hub device-identity connection-string show \
            --device-id ${{ steps.terraform_outputs.outputs.iot_simulator_device_name }} \
            --hub-name ${{ steps.terraform_outputs.outputs.iot_hub_name }} \
            --resource-group ${{ steps.terraform_outputs.outputs.resource_group_name }} \
            --query connectionString -o tsv)
          echo "IOTHUB_DEVICE_CONNECTION_STRING=$conn_str" >> $GITHUB_OUTPUT

      # --- 3. Docker Image Build and Push ---
      - name: Log in to Azure Container Registry
        uses: azure/docker-login@v1
        with:
          login-server: ${{ steps.terraform_outputs.outputs.acr_login_server }}
          username: ${{ secrets.AZURE_CLIENT_ID }}
          password: ${{ secrets.AZURE_CLIENT_SECRET }}

      - name: Build and Tag Docker image
        run: docker build -t ${{ steps.terraform_outputs.outputs.acr_login_server }}/iot-simulator:latest ./iot-simulator/

      - name: Push image to Azure Container Registry
        run: docker push ${{ steps.terraform_outputs.outputs.acr_login_server }}/iot-simulator:latest

      # --- 4. Inject ACR login server into simulator-deployment.yaml ---
      - name: Inject ACR login server into Kubernetes manifest
        run: |
          ACR=${{ steps.terraform_outputs.outputs.acr_login_server }}
          sed -i "s|<your-registry>|$ACR|g" ./kubernetes/simulator-deployment.yaml

      # --- 5. Kubernetes Deployment ---
      - name: Set up Kubeconfig for AKS
        run: |
          echo "Create ~/.kube directory"
          mkdir -p ~/.kube

          # Decode kubeconfig and write to ~/.kube/config
          echo "Decode kubeconfig and write to ~/.kube/config"
          # echo "${{ steps.terraform_outputs.outputs.AKS_KUBECFG }}" | base64 -d > ~/.kube/config
          echo "${{ steps.terraform_outputs.outputs.AKS_KUBECFG }}" > ~/.kube/config
          # Secure file permissions
          chmod 600 ~/.kube/config
          echo "Outputting ~/.kube/config"
          cat ~/.kube/config

      - name: Debug - Check Kubeconfig (OPTIONAL2)
        run: |
          echo "Contents of ~/.kube/config:"
          cat "$HOME/.kube/config"
          echo "terraform output -raw aks_kube_config | base64 | tr -d \ n:"
          terraform output -raw aks_kube_config | base64 | tr -d '\n'
          echo "terraform output -raw aks_kube_config  | tr -d \ n:"
          terraform output -raw aks_kube_config | tr -d '\n'
          echo "cat /home/runner/.kube/config"
          cat /home/runner/.kube/config
          echo "kubectl get nodes output:"
          kubectl get nodes # This should now work

        # No KUBECONFIG env needed here, as it's set globally via GITHUB_ENV

      - name: Debug - Check Kubeconfig (OPTIONAL)
        run: |
          ls -l ~/.kube/
          cat ~/.kube/config
          kubectl get nodes

      - name: Create Kubernetes Secret for IoT Simulator
        run: |
          echo -n "${{ steps.terraform_outputs.outputs.iothub_device_connection_string }}" | base64 -w 0 > conn_str_b64.txt
          echo -n "${{ steps.terraform_outputs.outputs.iot_simulator_device_name }}" | base64 -w 0 > device_simulator_name_b64.txt

          kubectl apply -f - <<EOF
          apiVersion: v1
          kind: Secret
          metadata:
            name: iot-credentials
          type: Opaque
          data:
            device-connection-string: $(cat conn_str_b64.txt)
            iot-simulator-device-name: $(cat device_simulator_name_b64.txt)
          EOF
        env:
          KUBECONFIG: ${{ steps.terraform_outputs.outputs.aks_kubecfg }}

      - name: Verify Kubernetes Deployment (Optional)
        run: |
          kubectl get pods -l app=iot-simulator
          kubectl get deployments iot-simulator
