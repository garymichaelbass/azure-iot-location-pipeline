# azure-iot-location-monitoring\.github\workflows\GithubActionsFullDeploy.yml

name: GitHub Actions Full IoT Solution Deployment

on:
  workflow_dispatch:  # Manual trigger from GitHub UI

# Change to this after debugging...
# on:
#   push:
#     branches: [ main ]

jobs:
  deploy-solution:
    runs-on: ubuntu-latest

    env:
      ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

    steps:
      # --- 1. Terraform Infrastructure Deployment ---
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.8.x

      - name: Terraform Init
        id: init
        run: terraform init
        working-directory: ./terraform

      - name: Force Unlock Terraform State (on failure/cancel with specific ID)
        # This step runs ONLY if a previous step (like 'Terraform Apply') failed or was cancelled.
        # This is the most reliable placement for cleaning up orphaned locks.
        if: ${{ failure() || cancelled() }}
        
        run: |
          echo "Attempting to find and force unlock the Terraform state lock ID..."

          # --- Backend configuration details from your backend.tf ---
          # These values MUST match your backend.tf exactly
          TF_BACKEND_ACCOUNT_NAME="iotlocationmon20250621"
          TF_BACKEND_CONTAINER_NAME="tfstate"
          TF_STATE_BLOB_KEY="iot-solution.tfstate" # This is the 'key' from your backend.tf

          # Ensure Azure CLI is logged in. The 'azure/login@v1' step earlier usually
          # takes care of this for the whole job, but it's good to be aware.

          # --- Attempt to get the lock ID from Azure Storage Blob metadata ---
          # This command queries the Azure storage blob for its metadata.
          # The 'terraformlockid' is a piece of metadata that Terraform writes when it acquires a lock.
          LOCK_ID=$(az storage blob metadata show \
            --account-name "$TF_BACKEND_ACCOUNT_NAME" \
            --container-name "$TF_BACKEND_CONTAINER_NAME" \
            --name "$TF_STATE_BLOB_KEY" \
            --query "metadata.terraformlockid" \
            --output tsv 2>/dev/null) # 2>/dev/null suppresses errors if blob/metadata not found

          if [ -n "$LOCK_ID" ]; then
            echo "ðŸ’¡ Found active lock ID: $LOCK_ID from Azure Storage metadata. Attempting force unlock..."
            # Execute the force-unlock command with the retrieved ID and the -force option
            # The || true ensures this cleanup step doesn't fail the workflow if unlock doesn't find the lock
            terraform force-unlock -force "$LOCK_ID" || {
              echo "âš ï¸ Warning: terraform force-unlock failed for ID $LOCK_ID. It might already be cleared or another issue exists."
              # If you want to stop the workflow if the force-unlock specifically fails, uncomment the line below:
              # exit 1
            }
            echo "âœ… Terraform force-unlock command completed for ID: $LOCK_ID."
          else
            echo "âœ… No active lock ID found in Azure Storage metadata for '$TF_STATE_BLOB_KEY'. No unlock needed."
          fi
        working-directory: ./terraform # Ensure this is the directory containing your backend.tf
        env:
          # These environment variables are crucial for 'az storage' commands
          # to authenticate to Azure to read blob metadata.
          # They are also used by terraform to interact with the backend.
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

      - name: Terraform Apply
        id: apply
        run: terraform apply -auto-approve
        working-directory: ./terraform
        env:
          TF_VAR_github_client_id: ${{ secrets.AZURE_CLIENT_ID }}
          TF_VAR_github_client_secret: ${{ secrets.AZURE_CLIENT_SECRET }}
          TF_VAR_github_tenant_id: ${{ secrets.AZURE_TENANT_ID }}
          TF_VAR_github_subscription_id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

      # --- 2. Extract Outputs from Terraform ---
      - name: Get Terraform Outputs (all except for IOTHUB_DEVICE_CONNECTION_STRING)
        id: terraform_outputs
        run: |
          TERRAFORM_OUTPUTS=$(terraform output -json)
          echo "IOT_SIMULATOR_DEVICE_NAME=$(echo $TERRAFORM_OUTPUTS | jq -r '.iot_simulator_device_name.value')" >> $GITHUB_OUTPUT
          echo "AKS_KUBECFG=$(echo $TERRAFORM_OUTPUTS | jq -r '.aks_kube_config.value' | base64 -w 0)" >> $GITHUB_OUTPUT
          echo "ACR_LOGIN_SERVER=$(echo $TERRAFORM_OUTPUTS | jq -r '.acr_login_server.value')" >> $GITHUB_OUTPUT
        working-directory: ./terraform

      - name: Get IoT device connection string via Azure CLI
        id: get_conn_str
        run: |
          conn_str=$(az iot hub device-identity connection-string show \
            --device-id ${{ steps.terraform_outputs.outputs.IOT_SIMULATOR_DEVICE_NAME }} \
            --hub-name ${{ steps.terraform_outputs.outputs.IOTHUB_NAME }} \
            --resource-group ${{ steps.terraform_outputs.outputs.RESOURCE_GROUP_NAME }} \
            --query connectionString -o tsv)
          echo "IOTHUB_DEVICE_CONNECTION_STRING=$conn_str" >> $GITHUB_OUTPUT

      # --- 3. Docker Image Build and Push ---
      - name: Log in to Azure Container Registry
        uses: azure/docker-login@v1
        with:
          login-server: ${{ steps.terraform_outputs.outputs.ACR_LOGIN_SERVER }}
          username: ${{ secrets.AZURE_CLIENT_ID }}
          password: ${{ secrets.AZURE_CLIENT_SECRET }}

      - name: Build and Tag Docker image
        run: docker build -t ${{ steps.terraform_outputs.outputs.ACR_LOGIN_SERVER }}/iot-simulator:latest ./iot-simulator/

      - name: Push image to Azure Container Registry
        run: docker push ${{ steps.terraform_outputs.outputs.ACR_LOGIN_SERVER }}/iot-simulator:latest

      # --- 4. Inject ACR login server into simulator-deployment.yaml ---
      - name: Inject ACR login server into Kubernetes manifest
        run: |
          ACR=${{ steps.terraform_outputs.outputs.ACR_LOGIN_SERVER }}
          sed -i "s|<your-registry>|$ACR|g" ./kubernetes/simulator-deployment.yaml

      # --- 5. Kubernetes Deployment ---
      - name: Set up Kubeconfig for AKS
        run: |
          echo "${{ steps.terraform_outputs.outputs.AKS_KUBECFG }}" | base64 -d > kubeconfig.yaml
          chmod 600 kubeconfig.yaml
          mkdir -p ~/.kube
          mv kubeconfig.yaml ~/.kube/config

      - name: Debug - Check Kubeconfig (OPTIONAL)
        run: |
          ls -l ~/.kube/
          cat ~/.kube/config
          kubectl get nodes

      - name: Create Kubernetes Secret for IoT Simulator
        run: |
          echo -n "${{ steps.terraform_outputs.outputs.IOTHUB_DEVICE_CONNECTION_STRING }}" | base64 -w 0 > conn_str_b64.txt
          echo -n "${{ steps.terraform_outputs.outputs.IOT_SIMULATOR_DEVICE_NAME }}" | base64 -w 0 > device_simulator_name_b64.txt

          kubectl apply -f - <<EOF
          apiVersion: v1
          kind: Secret
          metadata:
            name: iot-credentials
          type: Opaque
          data:
            device-connection-string: $(cat conn_str_b64.txt)
            iot-simulator-device-name: $(cat device_simulator_name_b64.txt)
          EOF
        env:
          KUBECONFIG: ${{ steps.terraform_outputs.outputs.AKS_KUBECFG }}

      - name: Verify Kubernetes Deployment (Optional)
        run: |
          kubectl get pods -l app=iot-simulator
          kubectl get deployments iot-simulator
